# 方案1：文档分块 + 摘要生成（优化版）

## 方案概述
```
大文档 → 智能分块(每块~2000字符) → 并发LLM摘要 → 拼接摘要 → 最终AI分析
```

## 技术架构

| 组件 | 技术选型 | 说明 |
|------|---------|------|
| 分块策略 | 智能语义分块 | 保持法律条文完整性，支持overlap |
| 摘要生成 | 并发调用LLM API | 每块生成100-200字摘要 |
| 异步处理 | @Async + CompletableFuture | 大文件不阻塞 |
| 进度反馈 | WebSocket推送 | 实时显示生成进度 |
| 缓存 | Redis | 重复文档避免重复生成 |
| 持久化 | 使用现有document表summary字段 | 需改为longtext |

## 与现有表结构兼容

当前 `document` 表已存在以下字段：
- `summary` - varchar(500)，需改为 **longtext** 支持长摘要
- 需新增：`summary_status`、`summary_chunks`、`summary_length`

## 配置项

```yaml
# application.yml

# Redis配置
spring:
  data:
    redis:
      host: localhost
      port: 6379
      password: ""
      database: 0
      timeout: 10000ms
      lettuce:
        pool:
          max-active: 20
          max-idle: 10
          min-idle: 5
          max-wait: -1ms

# 缓存配置
cache:
  type: redis
  redis:
    time-to-live: 3600s  # 缓存1小时
    use-key-prefix: true
    key-prefix: "police:kb:"

# 分块配置
chunking:
  strategy: smart  # simple/semantic/smart
  chunk-size: 2000
  chunk-overlap: 200
  max-chunks: 10
  min-chunk-size: 100

# 摘要配置
summary:
  enabled: true
  max-length: 200  # 摘要最大长度
  async-enabled: true  # 异步生成
```

### Redis Key设计

| Key | 类型 | 说明 |
|-----|------|------|
| `police:kb:summary:{docId}` | String | 文档摘要缓存 |
| `police:kb:summary:status:{docId}` | Hash | 摘要生成状态 |
| `police:kb:doc:{docId}:content` | String | 文档内容缓存（可选） |

## Redis缓存结构

```json
// 文档摘要
Key: police:kb:summary:12345
Value: {"docId":123,"content":"【第1部分】...","createdTime":"2026-02-05T10:00:00"}

// 摘要生成状态
Key: police:kb:summary:status:12345
Field:
  - status: "processing"
  - current: 5
  - total: 10
  - updatedTime: "2026-02-05T10:00:00"
```

## 数据库变更

```sql
-- 现有document表已有summary字段(varchar(500))，如需存储更长摘要，改为longtext
ALTER TABLE document MODIFY COLUMN summary LONGTEXT COMMENT '文档摘要';

-- 添加摘要状态和分块数字段
ALTER TABLE document ADD COLUMN summary_status VARCHAR(20) DEFAULT 'pending' COMMENT 'pending/processing/completed/failed';
ALTER TABLE document ADD COLUMN summary_chunks INT DEFAULT 0 COMMENT '分块数量';
ALTER TABLE document ADD COLUMN summary_length INT DEFAULT 0 COMMENT '摘要长度';

-- 如需分块存储，额外创建分块表
CREATE TABLE IF NOT EXISTS document_chunks (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    document_id BIGINT NOT NULL COMMENT '文档ID',
    chunk_index INT NOT NULL COMMENT '分块序号',
    content TEXT NOT NULL COMMENT '分块内容',
    summary TEXT COMMENT '分块摘要',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_document_id (document_id),
    UNIQUE KEY uk_doc_chunk (document_id, chunk_index)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文档分块表';
```

## Redis Key设计（配合现有表结构）

```yaml
# Key设计
police:kb:summary:content:{docId}    # 完整摘要内容 (String)
police:kb:summary:status:{docId}     # 生成状态 (Hash)
police:kb:summary:meta:{docId}      # 元数据 (Hash)
  - chunks: 5
  - length: 1500
  - createdTime: "2026-02-05T10:00:00"
```

## 获取摘要逻辑

```java
/**
 * 获取摘要 - 优先Redis缓存，其次数据库
 */
public String getSummary(Long docId) {
    // 1. 先查Redis缓存
    String cacheKey = SUMMARY_CACHE_KEY + docId;
    String cached = stringRedisTemplate.opsForValue().get(cacheKey);
    if (cached != null && !cached.isEmpty()) {
        return cached;
    }

    // 2. 查数据库（兼容现有summary字段）
    Document doc = documentMapper.selectById(docId);
    if (doc != null && doc.getSummary() != null && !doc.getSummary().isEmpty()) {
        // 回填Redis缓存
        stringRedisTemplate.opsForValue().set(
            cacheKey, doc.getSummary(), SUMMARY_CACHE_TTL, TimeUnit.SECONDS);
        return doc.getSummary();
    }

    return null;
}
```

## 实现步骤

### Step 1: 分块服务

**文件**: `backend/src/main/java/com/police/kb/service/DocumentChunkService.java`

```java
@Service
@Slf4j
public class DocumentChunkService {

    @Value("${chunking.chunk-size:2000}")
    private int chunkSize;

    @Value("${chunking.chunk-overlap:200}")
    private int chunkOverlap;

    @Value("${chunking.min-chunk-size:100}")
    private int minChunkSize;

    @Value("${chunking.strategy:semantic}")
    private String chunkingStrategy;

    /**
     * 智能分块
     */
    public List<DocumentChunk> chunkDocument(String content) {
        if (content == null || content.isEmpty()) {
            return new ArrayList<>();
        }

        switch (chunkingStrategy) {
            case "smart":
                return smartSemanticSplit(content);
            case "semantic":
                return splitBySemanticUnits(content);
            case "fixed":
            default:
                return fixedSizeSplit(content);
        }
    }

    /**
     * 智能语义分块 - 针对公安业务优化
     * 保持法律条文的完整性
     */
    private List<DocumentChunk> smartSemanticSplit(String content) {
        List<DocumentChunk> chunks = new ArrayList<>();
        if (content == null || content.isEmpty()) {
            return chunks;
        }

        // 1. 优先按法律条文分割 (§ 第X条、第XX条)
        List<String> articles = splitByArticles(content);

        // 2. 如果没有法律条文，按段落分割
        if (articles.size() <= 1) {
            articles = splitByParagraphs(content);
        }

        // 3. 对每个条目进行二次分块
        StringBuilder currentChunk = new StringBuilder();
        int chunkIndex = 0;

        for (String article : articles) {
            if (article.trim().isEmpty()) continue;

            // 如果单个条目太大，需要再次分割
            if (currentChunk.length() + article.length() > chunkSize) {
                if (currentChunk.length() >= minChunkSize) {
                    chunks.add(createChunk(currentChunk.toString(), chunkIndex++));
                    // 保留overlap
                    int start = Math.max(0, currentChunk.length() - chunkOverlap);
                    currentChunk = new StringBuilder(currentChunk.substring(start));
                }
            }

            if (currentChunk.length() > 0) {
                currentChunk.append("\n\n");
            }
            currentChunk.append(article.trim());

            // 防止单条过大
            if (currentChunk.length() > chunkSize * 1.5) {
                List<String> subChunks = splitFixed(currentChunk.toString(), chunkSize, chunkOverlap);
                for (int i = 0; i < subChunks.size() - 1; i++) {
                    chunks.add(createChunk(subChunks.get(i), chunkIndex++));
                }
                currentChunk = new StringBuilder(subChunks.get(subChunks.size() - 1));
            }
        }

        // 处理最后一块
        if (currentChunk.length() >= minChunkSize) {
            chunks.add(createChunk(currentChunk.toString(), chunkIndex));
        }

        log.info("智能分块完成: 输入长度={}, 输出chunk数={}", content.length(), chunks.size());
        return chunks;
    }

    /**
     * 按法律条文分割
     */
    private List<String> splitByArticles(String content) {
        List<String> articles = new ArrayList<>();
        Pattern pattern = Pattern.compile("(第[一二三四五六七八九十百千]+[条章款]|[§§])\\s*");
        String[] parts = pattern.split(content);

        for (String part : parts) {
            if (part.trim().length() >= minChunkSize) {
                articles.add(part.trim());
            }
        }

        if (articles.isEmpty()) {
            articles.add(content);
        }

        return articles;
    }

    /**
     * 按段落分割
     */
    private List<String> splitByParagraphs(String content) {
        List<String> paragraphs = new ArrayList<>();
        String[] parts = content.split("\n\n+");

        for (String part : parts) {
            if (part.trim().length() >= minChunkSize) {
                paragraphs.add(part.trim());
            }
        }

        if (paragraphs.isEmpty()) {
            paragraphs.add(content);
        }

        return paragraphs;
    }

    /**
     * 固定大小分块
     */
    private List<DocumentChunk> fixedSizeSplit(String content) {
        List<DocumentChunk> chunks = new ArrayList<>();
        String[] parts = splitFixed(content, chunkSize, chunkOverlap);

        for (int i = 0; i < parts.length; i++) {
            if (parts[i].trim().length() >= minChunkSize) {
                chunks.add(createChunk(parts[i].trim(), i));
            }
        }

        log.info("固定分块完成: 输入长度={}, 输出chunk数={}", content.length(), chunks.size());
        return chunks;
    }

    /**
     * 固定大小分割辅助方法
     */
    private List<String> splitFixed(String content, int size, int overlap) {
        List<String> parts = new ArrayList<>();
        for (int i = 0; i < content.length(); i += (size - overlap)) {
            int end = Math.min(i + size, content.length());
            String part = content.substring(i, end);
            if (part.trim().length() >= minChunkSize) {
                parts.add(part.trim());
            }
            if (end == content.length()) break;
        }
        return parts;
    }

    /**
     * 按语义单元分割
     */
    private List<DocumentChunk> splitBySemanticUnits(String content) {
        // 保留段落完整性，同时控制每块大小
        List<String> paragraphs = Arrays.asList(content.split("\n\n+"));
        List<DocumentChunk> chunks = new ArrayList<>();
        StringBuilder currentChunk = new StringBuilder();
        int chunkIndex = 0;

        for (String para : paragraphs) {
            if (currentChunk.length() + para.length() > chunkSize) {
                if (currentChunk.length() >= minChunkSize) {
                    chunks.add(createChunk(currentChunk.toString(), chunkIndex++));
                    int start = Math.max(0, currentChunk.length() - chunkOverlap);
                    currentChunk = new StringBuilder(currentChunk.substring(start));
                }
            }
            currentChunk.append(para).append("\n\n");
        }

        if (currentChunk.length() >= minChunkSize) {
            chunks.add(createChunk(currentChunk.toString(), chunkIndex));
        }

        return chunks;
    }

    private DocumentChunk createChunk(String content, int index) {
        DocumentChunk chunk = new DocumentChunk();
        chunk.setContent(content);
        chunk.setChunkIndex(index);
        chunk.setMetadata(Map.of("length", content.length()));
        return chunk;
    }

    /**
     * 批量保存分块
     */
    @Transactional
    public void saveChunks(Long documentId, List<DocumentChunk> chunks) {
        jdbcTemplate.batchUpdate(
            "INSERT INTO document_chunks (document_id, chunk_index, content) VALUES (?, ?, ?)",
            chunks.stream()
                .map(c -> new Object[]{documentId, c.getChunkIndex(), c.getContent()})
                .collect(Collectors.toList())
        );
    }
}

@Data
class DocumentChunk {
    private String content;
    private int chunkIndex;
    private Map<String, Object> metadata;
}
```

### Step 2: 摘要生成服务（异步 + 缓存）

**文件**: `backend/src/main/java/com/police/kb/service/DocumentSummaryService.java`

```java
@Service
@Slf4j
@RequiredArgsConstructor
public class DocumentSummaryService {

    private final LlmService llmService;
    private final JdbcTemplate jdbcTemplate;
    private final DocumentMapper documentMapper;

    @Value("${summary.max-length:200}")
    private int maxSummaryLength;

    @Value("${summary.async-enabled:true}")
    private boolean asyncEnabled;

    @Value("${summary.cache-enabled:true}")
    private boolean cacheEnabled;

    @Autowired
    private DocumentChunkService chunkService;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    private static final String SUMMARY_PROMPT = """
        请用%d字以内总结以下内容，要求：
        1. 保留核心要点
        2. 语言简洁明了
        3. 适用于后续法律问答参考

        内容：
        %s
        """;

    /**
     * 同步生成摘要
     */
    public String generateSummary(String content) {
        if (content == null || content.isEmpty()) {
            return "";
        }

        try {
            String prompt = String.format(SUMMARY_PROMPT, maxSummaryLength, content);
            return llmService.call(prompt);
        } catch (Exception e) {
            log.error("生成摘要失败: {}", e.getMessage());
            return content.substring(0, Math.min(200, content.length())) + "...";
        }
    }

    /**
     * 异步生成摘要（带进度回调和Redis状态）
     */
    @Async("summaryExecutor")
    public CompletableFuture<String> generateSummaryAsync(Long documentId,
            Consumer<Integer> onProgress) {
        Document doc = documentMapper.selectById(documentId);
        if (doc == null) {
            return CompletableFuture.failedFuture(new RuntimeException("文档不存在"));
        }

        try {
            // 更新Redis状态为processing
            updateSummaryStatus(documentId, "processing", 0, 10);

            // 分块
            List<DocumentChunk> chunks = chunkService.chunkDocument(doc.getContent());
            int totalChunks = Math.min(chunks.size(), 10); // 限制最大块数
            updateSummaryStatus(documentId, "processing", 0, totalChunks);

            if (chunks.isEmpty()) {
                String summary = "";
                saveSummary(documentId, summary, 0);
                return CompletableFuture.completedFuture(summary);
            }

            // 并发生成摘要
            List<CompletableFuture<String>> futures = new ArrayList<>();
            for (int i = 0; i < totalChunks; i++) {
                final int index = i;
                futures.add(CompletableFuture.supplyAsync(() ->
                    generateSummary(chunks.get(i).getContent())
                ));
            }

            // 等待所有摘要生成
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

            // 拼接摘要
            StringBuilder summaryBuilder = new StringBuilder();
            for (int i = 0; i < totalChunks; i++) {
                String chunkSummary = futures.get(i).get();
                summaryBuilder.append(String.format("【第%d部分】%s\n\n", i + 1, chunkSummary));

                // 更新Redis进度
                int current = i + 1;
                updateSummaryStatus(documentId, "processing", current, totalChunks);

                // WebSocket推送进度
                if (onProgress != null) {
                    onProgress.accept(current);
                }
            }

            String finalSummary = summaryBuilder.toString();

            // 保存到数据库
            saveSummary(documentId, finalSummary, totalChunks);

            // 设置Redis缓存
            setSummaryCache(documentId, finalSummary);

            log.info("文档摘要生成完成: docId={}, chunks={}", documentId, totalChunks);
            return CompletableFuture.completedFuture(finalSummary);

        } catch (Exception e) {
            log.error("异步生成摘要失败: docId={}", documentId, e);
            updateSummaryStatus(documentId, "failed", 0, 0);
            return CompletableFuture.failedFuture(e);
        }
    }

    /**
     * 获取缓存的摘要（Redis）
     */
    public String getCachedSummary(Long docId) {
        try {
            String cacheKey = SUMMARY_CACHE_KEY + docId;
            String cached = stringRedisTemplate.opsForValue().get(cacheKey);

            if (cached != null && !cached.isEmpty()) {
                log.debug("摘要缓存命中: docId={}", docId);
                return cached;
            }

            // 缓存未命中，从数据库获取
            Document doc = documentMapper.selectById(docId);
            if (doc != null && doc.getSummary() != null && !doc.getSummary().isEmpty()) {
                // 回填缓存
                stringRedisTemplate.opsForValue().set(
                    cacheKey,
                    doc.getSummary(),
                    SUMMARY_CACHE_TTL,
                    TimeUnit.SECONDS
                );
                return doc.getSummary();
            }

            return null;
        } catch (Exception e) {
            log.warn("获取摘要缓存失败: docId={}", docId, e);
            return null;
        }
    }

    /**
     * 设置摘要缓存（Redis）
     */
    public void setSummaryCache(Long docId, String summary) {
        try {
            String cacheKey = SUMMARY_CACHE_KEY + docId;
            stringRedisTemplate.opsForValue().set(
                cacheKey,
                summary,
                SUMMARY_CACHE_TTL,
                TimeUnit.SECONDS
            );
            log.debug("摘要缓存已设置: docId={}", docId);
        } catch (Exception e) {
            log.warn("设置摘要缓存失败: docId={}", docId, e);
        }
    }

    /**
     * 清除摘要缓存（Redis）
     */
    public void evictSummaryCache(Long docId) {
        try {
            String cacheKey = SUMMARY_CACHE_KEY + docId;
            stringRedisTemplate.delete(cacheKey);
            log.debug("摘要缓存已清除: docId={}", docId);
        } catch (Exception e) {
            log.warn("清除摘要缓存失败: docId={}", docId, e);
        }
    }

    /**
     * 获取摘要生成状态（Redis Hash）
     */
    public SummaryStatus getSummaryStatus(Long docId) {
        try {
            String statusKey = SUMMARY_STATUS_KEY + docId;
            Map<Object, Object> entries = stringRedisTemplate.opsForHash().entries(statusKey);

            if (entries.isEmpty()) {
                return null;
            }

            SummaryStatus status = new SummaryStatus();
            status.setDocId(docId);
            status.setStatus((String) entries.get("status"));
            status.setCurrent(entries.get("current") != null ?
                Integer.parseInt(entries.get("current").toString()) : 0);
            status.setTotal(entries.get("total") != null ?
                Integer.parseInt(entries.get("total").toString()) : 0);
            return status;
        } catch (Exception e) {
            log.warn("获取摘要状态失败: docId={}", docId, e);
            return null;
        }
    }

    /**
     * 更新摘要生成状态（Redis Hash）
     */
    public void updateSummaryStatus(Long docId, String status, int current, int total) {
        try {
            String statusKey = SUMMARY_STATUS_KEY + docId;
            Map<String, String> hash = new HashMap<>();
            hash.put("status", status);
            hash.put("current", String.valueOf(current));
            hash.put("total", String.valueOf(total));
            hash.put("updatedTime", LocalDateTime.now().toString());
            stringRedisTemplate.opsForHash().putAll(statusKey, hash);
            stringRedisTemplate.expire(statusKey, SUMMARY_CACHE_TTL, TimeUnit.SECONDS);
        } catch (Exception e) {
            log.warn("更新摘要状态失败: docId={}", docId, e);
        }
    }

    /**
     * 保存摘要到数据库（兼容现有表结构）
     */
    @Transactional
    public void saveSummary(Long documentId, String summary, int chunks) {
        jdbcTemplate.update(
            "UPDATE document SET summary = ?, summary_status = 'completed', " +
            "summary_chunks = ?, summary_length = ? WHERE id = ?",
            summary, chunks, summary != null ? summary.length() : 0, documentId
        );

        // 更新Redis状态为完成
        updateSummaryStatus(documentId, "completed", chunks, chunks);

        // 设置Redis缓存
        setSummaryCache(documentId, summary);

        // 清除进度监听
        String statusKey = SUMMARY_STATUS_KEY + documentId;
        stringRedisTemplate.delete(statusKey);
    }

    /**
     * 更新摘要状态（数据库）
     */
    private void updateSummaryStatus(Long documentId, String status, int chunks) {
        jdbcTemplate.update(
            "UPDATE document SET summary_status = ?, summary_chunks = ? WHERE id = ?",
            status, chunks, documentId
        );
    }

    /**
     * 检查是否需要重新生成摘要
     */
    public boolean needsResummary(Long docId) {
        try {
            // 先检查Redis状态
            SummaryStatus redisStatus = getSummaryStatus(docId);
            if (redisStatus != null && "completed".equals(redisStatus.getStatus())) {
                return false; // Redis中已完成
            }

            // 检查数据库
            Document doc = documentMapper.selectById(docId);
            if (doc == null) return true;
            String status = doc.getSummaryStatus();
            return status == null || "failed".equals(status) || "pending".equals(status);
        } catch (Exception e) {
            return true;
        }
    }

    /**
     * Redis缓存Key常量
     */
    private static final String SUMMARY_CACHE_KEY = "police:kb:summary:";
    private static final String SUMMARY_STATUS_KEY = "police:kb:summary:status:";
    private static final long SUMMARY_CACHE_TTL = 3600L; // 1小时

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Data
    public static class SummaryStatus {
        private Long docId;
        private String status;
        private int current;
        private int total;
    }
}
```
```

### Step 3: WebSocket进度推送

**文件**: `backend/src/main/java/com/police/kb/websocket/SummaryProgressWebSocket.java`

```java
@Component
@Slf4j
@ServerEndpoint("/ws/summary/progress/{docId}")
public class SummaryProgressWebSocket {

    private static final Map<Long, Set<Session>> docSessions = new ConcurrentHashMap<>();

    @OnOpen
    public void onOpen(@PathParam("docId") Long docId, Session session) {
        docSessions.computeIfAbsent(docId, k -> ConcurrentHashMap.newKeySet()).add(session);
        log.info("WebSocket连接建立: docId={}", docId);
    }

    @OnClose
    public void onClose(@PathParam("docId") Long docId, Session session) {
        Set<Session> sessions = docSessions.get(docId);
        if (sessions != null) {
            sessions.remove(session);
            if (sessions.isEmpty()) {
                docSessions.remove(docId);
            }
        }
    }

    /**
     * 推送进度
     */
    public void sendProgress(Long docId, int current, int total) {
        Set<Session> sessions = docSessions.get(docId);
        if (sessions != null && !sessions.isEmpty()) {
            String message = String.format("{\"type\":\"progress\",\"current\":%d,\"total\":%d}", current, total);
            sessions.forEach(session -> {
                try {
                    session.getBasicRemote().sendText(message);
                } catch (IOException e) {
                    log.warn("推送进度失败: docId={}", docId);
                }
            });
        }
    }

    /**
     * 推送完成
     */
    public void sendComplete(Long docId, String summary) {
        Set<Session> sessions = docSessions.get(docId);
        if (sessions != null && !sessions.isEmpty()) {
            String message = String.format("{\"type\":\"complete\",\"summary\":\"%s\"}",
                summary.replace("\"", "\\\""));
            sessions.forEach(session -> {
                try {
                    session.getBasicRemote().sendText(message);
                } catch (IOException e) {
                    log.warn("推送完成失败: docId={}", docId);
                }
            });
        }
    }
}
```

### Step 4: 新增摘要API

**文件**: `backend/src/main/java/com/police/kb/controller/DocumentSummaryController.java`

```java
@RestController
@RequestMapping("/api/v1/summary")
@RequiredArgsConstructor
public class DocumentSummaryController {

    private final DocumentSummaryService summaryService;
    private final DocumentMapper documentMapper;
    private final SummaryProgressWebSocket progressWebSocket;

    /**
     * 同步生成摘要（适合小文件）
     */
    @PostMapping("/sync")
    public Result<String> generateSummary(@RequestBody SummaryRequest request) {
        try {
            String summary = summaryService.generateSummary(request.getContent());
            return Result.success(summary);
        } catch (Exception e) {
            log.error("生成摘要失败", e);
            return Result.error("生成摘要失败: " + e.getMessage());
        }
    }

    /**
     * 异步生成摘要（适合大文件）
     */
    @PostMapping("/async/{docId}")
    public Result<Map<String, Object>> generateSummaryAsync(
            @PathVariable Long docId,
            @RequestBody(required = false) SummaryRequest request) {

        Document doc = documentMapper.selectById(docId);
        if (doc == null) {
            return Result.error("文档不存在");
        }

        // 启动异步任务
        summaryService.generateSummaryAsync(docId, (current, total) -> {
            progressWebSocket.sendProgress(docId, current, total);
        }).thenAccept(summary -> {
            progressWebSocket.sendComplete(docId, summary);
        }).exceptionally(e -> {
            log.error("异步摘要生成异常: docId={}", docId, e);
            return null;
        });

        return Result.success(Map.of(
            "docId", docId,
            "status", "processing",
            "message", "摘要生成任务已启动，请通过WebSocket监听进度"
        ));
    }

    /**
     * 获取摘要状态
     */
    @GetMapping("/status/{docId}")
    public Result<Map<String, Object>> getSummaryStatus(@PathVariable Long docId) {
        Document doc = documentMapper.selectById(docId);
        if (doc == null) {
            return Result.error("文档不存在");
        }

        return Result.success(Map.of(
            "docId", docId,
            "status", doc.getSummaryStatus() != null ? doc.getSummaryStatus() : "pending",
            "chunks", doc.getSummaryChunks() != null ? doc.getSummaryChunks() : 0,
            "summary", doc.getSummary() != null ? doc.getSummary() : ""
        ));
    }

    /**
     * 重新生成摘要
     */
    @PostMapping("/regenerate/{docId}")
    public Result<Map<String, Object>> regenerateSummary(@PathVariable Long docId) {
        summaryService.evictSummaryCache(docId);
        return generateSummaryAsync(docId, null);
    }

    /**
     * 批量生成摘要
     */
    @PostMapping("/batch")
    public Result<Map<String, Object>> batchGenerate(@RequestBody BatchSummaryRequest request) {
        Map<String, Object> results = new HashMap<>();
        int success = 0;
        int fail = 0;

        for (Long docId : request.getDocIds()) {
            try {
                if (summaryService.needsResummary(docId)) {
                    summaryService.generateSummaryAsync(docId, null);
                }
                results.put("doc_" + docId, "started");
                success++;
            } catch (Exception e) {
                results.put("doc_" + docId, "error: " + e.getMessage());
                fail++;
            }
        }

        results.put("success", success);
        results.put("fail", fail);

        return Result.success(results);
    }
}

@Data
class SummaryRequest {
    private String content;
}

@Data
class BatchSummaryRequest {
    private List<Long> docIds;
}
```

### Step 5: 修改对话接口支持摘要模式

**文件**: `backend/src/main/java/com/police/kb/controller/StreamChatController.java`

```java
@PostMapping(value = "/normal/{conversationId}", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public SseEmitter normalChat(
        @PathVariable Long conversationId,
        @RequestBody NormalChatRequest request) {

    String question = request.getQuestion();
    String models = request.getModels();
    List<NormalChatRequest.FileInfo> files = request.getFiles();
    Boolean useSummary = request.getUseSummary();  // 新增：是否使用摘要
    Integer summaryLevel = request.getSummaryLevel();  // brief/detailed

    // ... 现有初始化逻辑 ...

    // 如果使用摘要模式，处理文件
    if (useSummary != null && useSummary && files != null && !files.isEmpty()) {
        for (NormalChatRequest.FileInfo file : files) {
            String content = file.getContent();
            if (content != null && !content.isEmpty()) {
                // 检查是否已有缓存摘要
                String summary = null;
                if (file.getId() != null) {
                    summary = summaryService.getCachedSummary(file.getId());
                }

                if (summary == null || summary.isEmpty()) {
                    // 生成摘要（同步或异步）
                    summary = summaryService.generateSummary(content);
                }

                // 用摘要替换原文
                file.setContent(summary);
                file.setSummaryGenerated(true);
            }
        }
    }

    // ... 继续现有逻辑 ...
}
```

### Step 6: 前端实现

**文件**: `frontend/src/api/summary.ts`

```typescript
import request from '@/utils/request'

export interface SummaryRequest {
  content: string
}

export interface SummaryResponse {
  status: 'pending' | 'processing' | 'completed' | 'failed'
  chunks: number
  length: number  // 摘要长度
  summary: string
}

export interface BatchSummaryRequest {
  docIds: number[]
}

export const generateSummarySync = (content: string) => {
  return request.post<Result<string>>('/api/v1/summary/sync', { content })
}

export const generateSummaryAsync = (docId: number) => {
  return request.post<Result<{docId: number, status: string}>>(`/api/v1/summary/async/${docId}`)
}

export const getSummaryStatus = (docId: number) => {
  return request.get<Result<SummaryResponse>>(`/api/v1/summary/status/${docId}`)
}

export const regenerateSummary = (docId: number) => {
  return request.post<Result<any>>(`/api/v1/summary/regenerate/${docId}`)
}

export const batchGenerateSummary = (docIds: number[]) => {
  return request.post<Result<any>>('/api/v1/summary/batch', { docIds })
}
```

**文件**: `frontend/src/utils/websocket.ts`

```typescript
class SummaryWebSocket {
  private ws: WebSocket | null = null
  private docId: number | null = null
  private onProgress: ((current: number, total: number) => void) | null = null
  private onComplete: ((summary: string) => void) | null = null
  private onError: ((error: string) => void) | null = null

  connect(docId: number) {
    this.docId = docId
    this.ws = new WebSocket(`${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws/summary/progress/${docId}`)

    this.ws.onopen = () => {
      console.log('摘要进度WebSocket已连接')
    }

    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data)
      if (data.type === 'progress' && this.onProgress) {
        this.onProgress(data.current, data.total)
      } else if (data.type === 'complete' && this.onComplete) {
        this.onComplete(data.summary)
        this.close()
      }
    }

    this.ws.onerror = (error) => {
      console.error('WebSocket错误:', error)
      this.onError?.('连接失败')
    }
  }

  onProgress(callback: (current: number, total: number) => void) {
    this.onProgress = callback
    return this
  }

  onComplete(callback: (summary: string) => void) {
    this.onComplete = callback
    return this
  }

  onError(callback: (error: string) => void) {
    this.onError = callback
    return this
  }

  close() {
    this.ws?.close()
    this.ws = null
    this.docId = null
  }
}

export const summaryWS = new SummaryWebSocket()
```

**文件**: `frontend/src/views/document/components/DocumentSummaryCard.vue`

```vue
<template>
  <el-card class="summary-card">
    <template #header>
      <div class="card-header">
        <span>文档摘要</span>
        <div class="actions">
          <el-button
            v-if="summaryStatus === 'pending' || summaryStatus === 'failed'"
            type="primary"
            size="small"
            :loading="generating"
            @click="handleGenerate">
            生成摘要
          </el-button>
          <el-button
            v-if="summaryStatus === 'completed'"
            size="small"
            @click="handleRegenerate">
            重新生成
          </el-button>
        </div>
      </div>
    </template>

    <!-- 摘要内容 -->
    <div class="summary-content" v-if="summary">
      <el-input
        type="textarea"
        v-model="summary"
        :rows="6"
        resize="none"
        @blur="saveSummary" />
      <div class="summary-meta">
        <el-tag type="info" size="small">
          {{ chunkCount }} 个分块
        </el-tag>
        <el-tag type="success" size="small">
          约 {{ Math.round((summaryLength || summary.length) / 2) }} 字
        </el-tag>
      </div>
    </div>

    <!-- 生成进度 -->
    <div class="generating" v-else-if="generating">
      <el-progress
        :percentage="progressPercent"
        :status="progressPercent === 100 ? 'success' : ''" />
      <p class="progress-text">
        正在生成摘要 ({{ currentChunk }}/{{ totalChunks }} 块)
      </p>
    </div>

    <!-- 未生成状态 -->
    <div class="empty" v-else>
      <el-empty description="暂无摘要" :image-size="60">
        <el-button type="primary" @click="handleGenerate">
          点击生成摘要
        </el-button>
      </el-empty>
    </div>
  </el-card>
</template>

<script setup lang="ts">
import { ref, computed, onUnmounted } from 'vue'
import { getSummaryStatus, generateSummaryAsync, regenerateSummary } from '@/api/summary'
import { summaryWS } from '@/utils/websocket'
import { ElMessage } from 'element-plus'

const props = defineProps<{
  docId: number
}>()

const summary = ref('')
const summaryLength = ref(0)
const generating = ref(false)
const currentChunk = ref(0)
const totalChunks = ref(0)
const chunkCount = ref(0)

const summaryStatus = computed(() => {
  if (generating.value) return 'processing'
  if (summary.value) return 'completed'
  return 'pending'
})

const progressPercent = computed(() => {
  if (totalChunks.value === 0) return 0
  return Math.round((currentChunk.value / totalChunks.value) * 100)
})

// 加载摘要状态
const loadSummaryStatus = async () => {
  try {
    const res = await getSummaryStatus(props.docId)
    if (res.data) {
      summary.value = res.data.summary || ''
      summaryLength.value = res.data.length || 0
      chunkCount.value = res.data.chunks || 0
    }
  } catch (e) {
    console.error('加载摘要状态失败:', e)
  }
}

// 生成摘要
const handleGenerate = () => {
  generating.value = true
  currentChunk.value = 0
  totalChunks.value = 10

  // 连接WebSocket监听进度
  summaryWS
    .connect(props.docId)
    .onProgress((current, total) => {
      currentChunk.value = current
      totalChunks.value = total
    })
    .onComplete((resultSummary) => {
      summary.value = resultSummary
      generating.value = false
      ElMessage.success('摘要生成完成')
    })
    .onError((error) => {
      generating.value = false
      ElMessage.error(error)
    })

  // 调用API启动生成
  generateSummaryAsync(props.docId)
}

const handleRegenerate = () => {
  summary.value = ''
  handleGenerate()
}

const saveSummary = () => {
  // 可选：手动编辑后保存
}

onMounted(() => {
  loadSummaryStatus()
})

onUnmounted(() => {
  summaryWS.close()
})
</script>

<style scoped>
.summary-card {
  margin-bottom: 16px;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.summary-content {
  .el-textarea {
    margin-bottom: 12px;
  }
}

.summary-meta {
  display: flex;
  gap: 8px;
}

.generating {
  text-align: center;
  padding: 20px 0;
}

.progress-text {
  margin-top: 12px;
  color: #909399;
  font-size: 14px;
}
</style>
```

**文件**: `frontend/src/views/chat/normal/components/FileUploader.vue` (更新)

```vue
<template>
  <div class="file-uploader">
    <!-- 摘要模式开关 -->
    <div class="mode-switch">
      <el-switch
        v-model="useSummaryMode"
        active-text="摘要模式"
        inactive-text="完整模式"
        @change="onModeChange" />
      <el-tooltip content="大文件自动分块摘要，降低Token消耗" placement="top">
        <el-icon class="tip-icon"><QuestionFilled /></el-icon>
      </el-tooltip>
    </div>

    <!-- 上传区域 -->
    <el-upload
      v-if="!disabled"
      ref="uploadRef"
      :action="uploadUrl"
      :headers="uploadHeaders"
      :multiple="multiple"
      :limit="limit"
      :file-list="fileList"
      :before-upload="beforeUpload"
      :on-success="onUploadSuccess"
      :on-error="onUploadError"
      :on-exceed="onExceed"
      drag
      class="upload-area">
      <el-icon class="upload-icon"><UploadFilled /></el-icon>
      <div class="upload-text">
        <span>拖拽文件到此处，或<em>点击上传</em></span>
        <span class="hint">支持 PDF/Word/Excel/TXT/MD，单文件最大100MB</span>
      </div>
    </el-upload>

    <!-- 文件列表 -->
    <div class="file-list" v-if="files.length > 0">
      <div class="file-item" v-for="(file, index) in files" :key="index">
        <div class="file-info">
          <el-icon class="file-icon"><Document /></el-icon>
          <div class="file-details">
            <span class="file-name">{{ file.name }}</span>
            <span class="file-size">{{ formatFileSize(file.size || 0) }}</span>
          </div>
        </div>

        <div class="file-status">
          <!-- 摘要状态标签 -->
          <el-tag
            v-if="useSummaryMode && file.summaryGenerated"
            type="success"
            size="small">
            已摘要
          </el-tag>
          <el-tag
            v-else-if="useSummaryMode && file.processing"
            type="warning"
            size="small"
            :loading="file.processing">
            摘要中...
          </el-tag>
          <el-tag
            v-else-if="useSummaryMode"
            type="info"
            size="small"
            @click="generateSummaryForFile(file)"
            class="clickable">
            未摘要
          </el-tag>
        </div>

        <el-button
          type="danger"
          size="small"
          circle
          @click="removeFile(index)">
          <el-icon><Delete /></el-icon>
        </el-button>
      </div>
    </div>

    <!-- 摘要预览弹窗 -->
    <el-dialog
      v-model="previewDialogVisible"
      title="摘要预览"
      width="600px">
      <el-input
        type="textarea"
        v-model="previewSummary"
        :rows="10"
        readonly />
      <template #footer>
        <el-button @click="previewDialogVisible = false">关闭</el-button>
        <el-button type="primary" @click="applySummary">应用摘要</el-button>
      </template>
    </el-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import { UploadFilled, Document, Delete, QuestionFilled } from '@element-plus/icons-vue'
import { ElMessage } from 'element-plus'
import { generateSummarySync } from '@/api/summary'
import { useUserStore } from '@/stores/user'

interface FileData {
  id?: number
  name: string
  size: number
  content?: string
  url?: string
  type?: string
  summary?: string
  summaryGenerated?: boolean
  processing?: boolean
}

const props = defineProps<{
  files: FileData[]
  disabled?: boolean
  multiple?: boolean
  limit?: number
}>()

const emit = defineEmits<{
  (e: 'update:files', files: FileData[]): void
}>()

const userStore = useUserStore()
const useSummaryMode = ref(false)
const fileList = ref([])
const previewDialogVisible = ref(false)
const previewSummary = ref('')

const uploadUrl = import.meta.env.VITE_API_BASE_URL + '/api/v1/files/upload'
const uploadHeaders = computed(() => ({
  Authorization: `Bearer ${userStore.token}`
}))

const onModeChange = (value: boolean) => {
  // 切换模式时处理文件
  if (value) {
    files.value.forEach(file => {
      if (!file.summaryGenerated && !file.processing) {
        generateSummaryForFile(file)
      }
    })
  }
}

// 为单个文件生成摘要
const generateSummaryForFile = async (file: FileData) => {
  if (!file.content) {
    ElMessage.warning('文件内容为空，无法生成摘要')
    return
  }

  file.processing = true
  try {
    const res = await generateSummarySync(file.content.substring(0, 10000)) // 限制内容长度
    file.summary = res.data
    file.summaryGenerated = true
    ElMessage.success('摘要生成成功')
  } catch (e) {
    ElMessage.error('摘要生成失败')
  } finally {
    file.processing = false
  }
}

const beforeUpload = (file: File) => {
  const isValidType = ['pdf', 'word', 'excel', 'txt', 'md'].some(ext =>
    file.name.toLowerCase().endsWith('.' + ext)
  )
  if (!isValidType) {
    ElMessage.error('不支持的文件类型')
    return false
  }
  const isLt100M = file.size / 1024 / 1024 < 100
  if (!isLt100M) {
    ElMessage.error('文件大小不能超过100MB')
    return false
  }
  return true
}

const onUploadSuccess = (res: any, file: File) => {
  const fileData: FileData = {
    id: res.data.id,
    name: file.name,
    size: file.size,
    url: res.data.url,
    type: res.data.type
  }
  emit('update:files', [...props.files, fileData])

  // 自动生成摘要（如果是摘要模式）
  if (useSummaryMode.value) {
    generateSummaryForFile(fileData)
  }
}

const onUploadError = () => {
  ElMessage.error('文件上传失败')
}

const onExceed = () => {
  ElMessage.warning(`最多只能上传 ${props.limit || 10} 个文件`)
}

const removeFile = (index: number) => {
  const newFiles = [...props.files]
  newFiles.splice(index, 1)
  emit('update:files', newFiles)
}

const formatFileSize = (bytes: number) => {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

watch(() => props.files, (newFiles) => {
  // 确保每个文件都有处理状态
  newFiles.forEach(file => {
    if (file.processing === undefined) file.processing = false
    if (file.summaryGenerated === undefined) file.summaryGenerated = false
  })
}, { deep: true, immediate: true })
</script>

<style scoped>
.file-uploader {
  padding: 16px;
  background: #f5f7fa;
  border-radius: 8px;
}

.mode-switch {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
}

.tip-icon {
  color: #909399;
  cursor: help;
}

.upload-area {
  :deep(.el-upload-dragger) {
    padding: 24px;
  }
}

.upload-icon {
  font-size: 32px;
  color: #409eff;
}

.upload-text {
  margin-top: 8px;
  text-align: center;
}

.upload-text .hint {
  display: block;
  margin-top: 4px;
  font-size: 12px;
  color: #909399;
}

.file-list {
  margin-top: 16px;
}

.file-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: #fff;
  border-radius: 6px;
  margin-bottom: 8px;
}

.file-info {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
}

.file-icon {
  font-size: 24px;
  color: #409eff;
}

.file-details {
  display: flex;
  flex-direction: column;
}

.file-name {
  font-weight: 500;
}

.file-size {
  font-size: 12px;
  color: #909399;
}

.clickable {
  cursor: pointer;
}
</style>
```

## 复杂度评估

| 维度 | 评分(1-5) | 说明 |
|------|-----------|------|
| 实现难度 | 2 | 只需后端服务，前端改动小 |
| 维护成本 | 2 | 结构简单，易于维护 |
| Token消耗 | 3 | 摘要+最终分析，约原文档30% |
| 准确性 | 3 | 可能丢失细节，但成本低 |

## 预估工作量

```
后端: 3天
├── DocumentChunkService.java (0.5天)  ⬅️ 优化为智能分块
├── DocumentSummaryService.java (1天)  ⬅️ 新增：异步+缓存
├── SummaryProgressWebSocket.java (0.5天) ⬅️ 新增：进度推送
└── DocumentSummaryController.java (1天)  ⬅️ 新增完整API

前端: 1.5天
├── api/summary.ts (0.25天)
├── utils/websocket.ts (0.25天)
├── DocumentSummaryCard.vue (0.5天) ⬅️ 新增：摘要卡片组件
└── FileUploader.vue更新 (0.5天)

测试: 1天
└── 功能测试 + 边界测试

总计: 5.5天
```

## 风险与对策

| 风险 | 概率 | 影响 | 对策 |
|------|------|------|------|
| 摘要丢失重要信息 | 中 | 中 | 提供"完整模式"选项，用户可选 |
| 异步处理失败 | 低 | 中 | WebSocket推送失败状态，支持重试 |
| 摘要生成耗时 | 中 | 低 | 异步处理，WebSocket进度反馈 |
| LLM调用成本 | 低 | 低 | 控制maxChunks，默认10块 |
| WebSocket连接不稳定 | 中 | 低 | 断线重连机制 |

## 验收标准

- [ ] 支持PDF/Word/Excel/TXT/MD文件
- [ ] 文件自动分块(默认最大10块)
- [ ] 每块生成100字摘要
- [ ] 摘要模式开关可控制
- [ ] 完整/摘要模式可切换
- [ ] 前端显示摘要生成状态和进度
- [ ] 支持异步生成和大文件
- [ ] 摘要持久化到document表summary字段
- [ ] Redis缓存摘要（TTL 1小时）
- [ ] Redis Hash存储生成状态
- [ ] 重复文档可使用缓存摘要
- [ ] Token消耗降低50%以上

## 后续扩展

- [ ] 摘要编辑功能（用户可修正AI摘要）
- [ ] 批量摘要管理
- [ ] 摘要对比功能
- [ ] 智能推荐摘要策略

## 与方案2(RAG)的关系

方案1和方案2可以**互补使用**：

| 场景 | 推荐方案 |
|------|---------|
| 简单文档总结 | 方案1（摘要） |
| 法规条文问答 | 方案2（RAG） |
| 超大文档处理 | 方案1（摘要）+ 方案2（RAG） |
| 多知识库检索 | 方案2（RAG） |

**推荐**：两个方案都实现，让用户根据场景选择。

## 确认清单

请确认以下内容：

- [ ] 方案1采用异步处理 + WebSocket进度反馈
- [ ] 使用Redis作为缓存（TTL 1小时）
- [ ] Redis Hash存储生成状态
- [ ] 兼容现有document表结构
- [ ] 修改summary字段为longtext
- [ ] 预估工作量：5.5天
- [ ] 前端增加摘要卡片组件

**确认后请回复"确认实施"，我将开始开发。**

---

## 数据库迁移脚本

```sql
-- 方案1数据库变更（基于现有document表）

-- 1. 修改summary字段类型（500字符不够用）
ALTER TABLE document MODIFY COLUMN summary LONGTEXT COMMENT '文档摘要';

-- 2. 添加摘要相关字段
ALTER TABLE document
ADD COLUMN summary_status VARCHAR(20) DEFAULT 'pending' COMMENT 'pending/processing/completed/failed' AFTER summary,
ADD COLUMN summary_chunks INT DEFAULT 0 COMMENT '分块数量' AFTER summary_status,
ADD COLUMN summary_length INT DEFAULT 0 COMMENT '摘要长度' AFTER summary_chunks;

-- 3. 创建分块表（如需存储分块详情）
CREATE TABLE IF NOT EXISTS document_chunks (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    document_id BIGINT NOT NULL COMMENT '文档ID',
    chunk_index INT NOT NULL COMMENT '分块序号',
    content TEXT NOT NULL COMMENT '分块内容',
    summary TEXT COMMENT '分块摘要',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_document_id (document_id),
    UNIQUE KEY uk_doc_chunk (document_id, chunk_index)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文档分块表';
```
